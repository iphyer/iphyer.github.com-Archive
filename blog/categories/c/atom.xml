<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C | 桑弧蓬矢射四方]]></title>
  <link href="http://iphyer.github.com/blog/categories/c/atom.xml" rel="self"/>
  <link href="http://iphyer.github.com/"/>
  <updated>2018-04-30T20:49:04-05:00</updated>
  <id>http://iphyer.github.com/</id>
  <author>
    <name><![CDATA[iphyer]]></name>
    <email><![CDATA[iphyer@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C语言的Argp的使用]]></title>
    <link href="http://iphyer.github.com/blog/2014/05/01/c-ex-argp/"/>
    <updated>2014-05-01T19:03:00-05:00</updated>
    <id>http://iphyer.github.com/blog/2014/05/01/c-ex-argp</id>
    <content type="html"><![CDATA[<h1 id="section">说明</h1>

<p>Argp一般是GNU C用来处理程序参数的接口函数。</p>

<p>详情可以参考GNU的<a href="http://www.gnu.org/software/libc/manual/html_node/Argp.html">说明</a>。</p>

<blockquote>
  <p>Argp provides features unavailable in the more commonly used getopt interface. These features include automatically producing output in response to the ‘–help’ and ‘–version’ options, as described in the GNU coding standards. Using argp makes it less likely that programmers will neglect to implement these additional options or keep them up to date.</p>
</blockquote>

<blockquote>
  <p>Argp also provides the ability to merge several independently defined option parsers into one, mediating conflicts between them and making the result appear seamless. A library can export an argp option parser that user programs might employ in conjunction with their own option parsers, resulting in less work for the user programs. Some programs may use only argument parsers exported by libraries, thereby achieving consistent and efficient option-parsing for abstractions implemented by the libraries.</p>
</blockquote>

<!--more-->

<h1 id="section-1">实例</h1>

<p>这个程序来自GNU C的例子程序，因为我在命名C程序的时候错误使用了C++的.C命名结果一直没有办法编译通过，最后只好删除了。
其实不应该，下次即使是程序的中间结果也应该保留，因为毕竟是自己的劳动么，可以注释掉但是不要删除。
删除是浪费的。</p>

<pre><code>  /* This program uses the same features as example 2, and uses options and
        arguments.
     
        We now use the first four fields in ARGP, so here's a description of them:
          OPTIONS  -- A pointer to a vector of struct argp_option (see below)
          PARSER   -- A function to parse a single option, called by argp
          ARGS_DOC -- A string describing how the non-option arguments should look
          DOC      -- A descriptive string about this program; if it contains a
                      vertical tab character (\v), the part after it will be
                      printed *following* the options
     
        The function PARSER takes the following arguments:
          KEY  -- An integer specifying which option this is (taken
                  from the KEY field in each struct argp_option), or
                  a special key specifying something else; the only
                  special keys we use here are ARGP_KEY_ARG, meaning
                  a non-option argument, and ARGP_KEY_END, meaning
                  that all arguments have been parsed
          ARG  -- For an option KEY, the string value of its
                  argument, or NULL if it has none
          STATE-- A pointer to a struct argp_state, containing
                  various useful information about the parsing state; used here
                  are the INPUT field, which reflects the INPUT argument to
                  argp_parse, and the ARG_NUM field, which is the number of the
                  current non-option argument being parsed
        It should return either 0, meaning success, ARGP_ERR_UNKNOWN, meaning the
        given KEY wasn't recognized, or an errno value indicating some other
        error.
     
        Note that in this example, main uses a structure to communicate with the
        parse_opt function, a pointer to which it passes in the INPUT argument to
        argp_parse.  Of course, it's also possible to use global variables
        instead, but this is somewhat more flexible.
     
        The OPTIONS field contains a pointer to a vector of struct argp_option's;
        that structure has the following fields (if you assign your option
        structures using array initialization like this example, unspecified
        fields will be defaulted to 0, and need not be specified):
          NAME   -- The name of this option's long option (may be zero)
          KEY    -- The KEY to pass to the PARSER function when parsing this option,
                    *and* the name of this option's short option, if it is a
                    printable ascii character
          ARG    -- The name of this option's argument, if any
          FLAGS  -- Flags describing this option; some of them are:
                      OPTION_ARG_OPTIONAL -- The argument to this option is optional
                      OPTION_ALIAS        -- This option is an alias for the
                                             previous option
                      OPTION_HIDDEN       -- Don't show this option in --help output
          DOC    -- A documentation string for this option, shown in --help output
     
        An options vector should be terminated by an option with all fields zero. */
     
     #include &lt;stdlib.h&gt;
     #include &lt;argp.h&gt;
     
     const char *argp_program_version =
       "argp-ex3 1.0";
     const char *argp_program_bug_address =
       "&lt;bug-gnu-utils@gnu.org&gt;";
     
     /* Program documentation. */
     static char doc[] =
       "Argp example #3 -- a program with options and arguments using argp";
     
     /* A description of the arguments we accept. */
     static char args_doc[] = "ARG1 ARG2";
     
     /* The options we understand. */
     static struct argp_option options[] = {
       {"verbose",  'v', 0,      0,  "Produce verbose output" },
       {"quiet",    'q', 0,      0,  "Don't produce any output" },
       {"silent",   's', 0,      OPTION_ALIAS },
       {"output",   'o', "FILE", 0,
        "Output to FILE instead of standard output" },
       { 0 }
     };
     
     /* Used by main to communicate with parse_opt. */
     struct arguments
     {
       char *args[2];                /* arg1 &amp; arg2 */
       int silent, verbose;
       char *output_file;
     };
     
     /* Parse a single option. */
     static error_t
     parse_opt (int key, char *arg, struct argp_state *state)
     {
       /* Get the input argument from argp_parse, which we
          know is a pointer to our arguments structure. */
       struct arguments *arguments = state-&gt;input;
     
       switch (key)
         {
         case 'q': case 's':
           arguments-&gt;silent = 1;
           break;
         case 'v':
           arguments-&gt;verbose = 1;
           break;
         case 'o':
           arguments-&gt;output_file = arg;
           break;
     
         case ARGP_KEY_ARG:
           if (state-&gt;arg_num &gt;= 2)
             /* Too many arguments. */
             argp_usage (state);
     
           arguments-&gt;args[state-&gt;arg_num] = arg;
     
           break;
     
         case ARGP_KEY_END:
           if (state-&gt;arg_num &lt; 2)
             /* Not enough arguments. */
             argp_usage (state);
           break;
     
         default:
           return ARGP_ERR_UNKNOWN;
         }
       return 0;
     }
     
     /* Our argp parser. */
     static struct argp argp = { options, parse_opt, args_doc, doc };
     
     int
     main (int argc, char **argv)
     {
       struct arguments arguments;
     
       /* Default values. */
       arguments.silent = 0;
       arguments.verbose = 0;
       arguments.output_file = "-";
     
       /* Parse our arguments; every option seen by parse_opt will
          be reflected in arguments. */
       argp_parse (&amp;argp, argc, argv, 0, 0, &amp;arguments);
     
       printf ("ARG1 = %s\nARG2 = %s\nOUTPUT_FILE = %s\n"
               "VERBOSE = %s\nSILENT = %s\n",
               arguments.args[0], arguments.args[1],
               arguments.output_file,
               arguments.verbose ? "yes" : "no",
               arguments.silent ? "yes" : "no");
     
       exit (0);
     }
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C语言的Argv的使用]]></title>
    <link href="http://iphyer.github.com/blog/2014/05/01/c-ex-argv/"/>
    <updated>2014-05-01T18:48:00-05:00</updated>
    <id>http://iphyer.github.com/blog/2014/05/01/c-ex-argv</id>
    <content type="html"><![CDATA[<h2 id="section">起因</h2>

<p>前段时间看了一本书，The GNU C Programing Tutorial <a href="http://crasseux.com/books/ctutorial/">weblink</a>。收获很大，其实你从K&amp;R那里学来的不一定是GNU C的规范，
最最不错的是这本书不是中国大学C教程那种大路货的教材，这本书教材基本上把整个流程串联起来了。其实如果一本书不讲解makefile基本上不能算是一本成熟的c语言书，除非你一直只是编写
一些小工的程序。</p>

<p>下面摘抄一段自己的豆瓣书评：</p>

<blockquote>
  <p>虽然是入门书，但是对比K&amp;R的书来说更加入门，而且融入了GNU的基因，当然这本书只是入门！教程就是教程不是指南，不过看完这本再看K&amp;R你会理解的更深刻！我是在酷壳上看到陈浩大神的推荐才看的，发现果然收获很大，这个不再是单单的讲解语言更加是GNU系统的一个解释，后面也讲到Make和GDB，不过是不是我下载的版本问题GDB部分没有内容？但是综合而言还是所获很多，如果你重度依赖GCC那么还是值得一看的，语言非常Simple,非常适合入门当然收获更大的是你有了C的基础但是一直不太清楚GNU C的约定的时候！</p>
</blockquote>

<!--more-->

<h2 id="argv">argv的使用</h2>

<pre><code>#include &lt;stdio.h&gt;

int main (int argc,char *argv[])
{
	int count;
	
	printf ("This program was called with \" %s \".\n",argv[0]);
	if (argc &gt;1)
	{
			for (count = 1 ; count &lt; argc; count++)
			{
					printf ("argv[%d]=%s \n",count,argv[count]);
			}
	}
	else
	{
		printf("the command had no other arguments. \n");
	}
	return 0;
}
#include &lt;stdio.h&gt;

int main (int argc,char *argv[])
{
	int count;
	
	printf ("This program was called with \" %s \".\n",argv[0]);
	if (argc &gt;1)
	{
			for (count = 1 ; count &lt; argc; count++)
			{
					printf ("argv[%d]=%s \n",count,argv[count]);
			}
	}
	else
	{
		printf("the command had no other arguments. \n");
	}
	return 0;
}
</code></pre>

<p>输出示例：</p>

<pre><code> ./17argc a v x
 

This program was called with " ./17argc ".
argv[1]=a 
argv[2]=v 
argv[3]=x 
</code></pre>
]]></content>
  </entry>
  
</feed>
